// BEGIN PROGRAM
7 0 27 // Jump to line 27 (in this file, line 33)

// BEGIN PROCEDURE fact
7 0 2 // Jump ahead one line, redundant
6 0 5 // Make room for AR (1 var ansl, so 4 + 1)
3 1 5 // Load val stored 1 level below, spot 5 (in this case, n)
4 0 4 // Store val 0 levels below, spot 4 (in this case, ansl)
3 1 5 // Load val stored 1 level below, spot 5 (in this case, n)
1 0 1 // Push val 3 to stack
2 0 3 // Opr sub
4 1 5 // Store val 1 level below, spot 5 (in this case, n)
3 1 5 // Load val stored 1 level below, spot 5 (in this case, n)
1 0 0 // Push val 0 to stack
2 0 8 // Opr eq
8 0 16 // If top of stack == 0, then failed if. jump to line 16 (in this file, line 20)
1 0 1 // Push val 1 to stack
4 1 4 // Store val 1 level below, spot 4 (in this case, f)
7 0 16 // Jump to line 16 (in this file, line 20), seems like it's redundant
3 1 5 // Load val stored 1 level below, spot 5 (in this case, n)
1 0 0 // Push val 0 to stack
2 0 12 // Opr gtr
8 0 22 // If top of stack == 0, then failed if. Jump to line 22 (in this file, line 26)
5 1 1 // Call proc (jumps to line number in m from level l, in this file line 2)
7 0 22 // Jump to line 22 (in this file, line 26), redundant
3 1 4 // Load val stored 1 level below, spot 4 (in this case, f)
3 0 4 // Load val stored 0 levels below, spot 4 (in this ase, ansl)
2 0 4 // Opr mult
4 1 4 // Store val 1 level below, spot 4 (in this case, f)
2 0 0 // return

// BEGIN MAIN
6 0 6 // Make room for AR (2 vars f, n, so 4 + 2)
1 0 3 // Push val 3 to stack
4 0 5 // Store value in slot 5, in this case n (removes val we just pushed)
5 0 1 // Call proc (jumps to line number in m from level l, in this file line 5)
3 0 4 // Load val stored 0 levels below, spot 4 (in this case, f)
9 0 1 // Write val
11 0 3 // Halt
